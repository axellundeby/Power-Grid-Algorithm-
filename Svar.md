# Answer File - Semester 2
# Description of each Implementation
Briefly describe your implementation of the different methods. What was your idea and how did you execute it? If there were any problems and/or failed implementations please add a description.

## Task 1 - mst
*Enter description*

## Task 2 - lca
*Enter description*

## Task 3 - addRedundant
*Enter description*


Tanken bak dette er 책 favorisere stier som g책r gjennom noder med mange naboer, da de bidrar mer til den akkumulerte scoren. Den akkumulerte scoren fungerer som en heuristikk for 책 bestemme den "beste" stien gjennom grafen basert p책 antallet naboer hver node har.

# Runtime Analysis
For each method of the different strategies give a runtime analysis in Big-O notation and a description of why it has this runtime.

**If you have implemented any helper methods you must add these as well.**

* ``mst(WeightedGraph<T, E> g)``: O(?)
    * *Insert description of why the method has the given runtime*
* ``lca(Graph<T> g, T root, T u, T v)``: O(?)
    * *Insert description of why the method has the given runtime*
* ``addRedundant(Graph<T> g, T root)``: O(?)
    * *Insert description of why the method has the given runtime*

